/**
 * @file face.c
 * @author khalilhenoud@gmail.com
 * @brief
 * @version 0.1
 * @date 2023-06-10
 *
 * @copyright Copyright (c) 2023
 *
 */
#include <assert.h>
#include <math.h>
#include <math/face.h>


inline
face_t
get_extended_face(
  const face_t* face,
  float radius)
{
  assert(face);

  {
    face_t augmented;
    float angles[3];
    float dot_product;
    float k;
    vector3f offset;
    vector3f avec[2];
    uint32_t vec0[3][2] = { {0, 1}, {1, 2}, {2, 0} };
    uint32_t vec1[3][2] = { {0, 2}, {1, 0}, {2, 1} };
    for (uint32_t i = 0; i < 3; ++i) {
      vector3f_set_diff_v3f(
        avec + 0, &face->points[vec0[i][0]], &face->points[vec0[i][1]]);
      normalize_set_v3f(avec + 0);
      vector3f_set_diff_v3f(
        avec + 1, &face->points[vec1[i][0]], &face->points[vec1[i][1]]);
      normalize_set_v3f(avec + 1);

      dot_product = dot_product_v3f(avec + 0, avec + 1);
      angles[i] = acosf(fabs(dot_product));

      k = radius / sinf(angles[i]);
      vector3f_copy(augmented.points + i, face->points + i);
      mult_set_v3f(avec + 0, -k);
      mult_set_v3f(avec + 1, -k);
      vector3f_copy(&offset, avec + 0);
      add_set_v3f(&offset, avec + 1);
      add_set_v3f(augmented.points + i, &offset);
    }

    return augmented;
  }
}

inline
void
get_faces_normals(
  const face_t *faces,
  const uint32_t count,
  vector3f *normals)
{
  vector3f v1, v2;

  assert(normals != NULL);

  for (uint32_t i = 0; i < count; ++i) {
    vector3f_set_diff_v3f(&v1, &faces[i].points[0], &faces[i].points[1]);
    vector3f_set_diff_v3f(&v2, &faces[i].points[0], &faces[i].points[2]);
    normals[i] = cross_product_v3f(&v1, &v2);
    normalize_set_v3f(normals + i);
  }
}

inline
float
get_point_distance(
  const face_t *face,
  const vector3f *normal,
  const point3f *point)
{
  vector3f to_point = diff_v3f(&face->points[0], point);
  return dot_product_v3f(normal, &to_point);
}

inline
point3f
get_point_projection(
  const face_t *face,
  const vector3f *normal,
  const point3f *point,
  float *distance)
{
  assert(distance != NULL);
  *distance = get_point_distance(face, normal, point);

  {
    vector3f scaled_normal = mult_v3f(normal, *distance);
    point3f projected = diff_v3f(&scaled_normal, point);
    return projected;
  }
}